use std::{
    future::{poll_fn, Future},
    io,
    net::SocketAddr,
    pin::Pin,
    task::Poll,
};

use dust_devil_core::{
    sandstorm::SandstormCommandType,
    serialize::{ByteWrite, SmallWriteList},
};
use tokio::{
    io::{AsyncWrite, AsyncWriteExt, BufWriter},
    select,
    sync::{mpsc, oneshot},
};

use crate::context::SandstormContext;

use super::{error_handling::ToIoResult, messaging::ResponseNotification};

/// The maximum amount requests for a specific message type (e.g. "list socks5 sockets") that can
/// pile up before the response handler starts waiting on them to be completed synchronously.
///
/// This doesn't need to be a high value; why would anyone be asking to list/add/remove a socks5 or
/// sandstorm sockets over and over again repeatedly without delay? 4 is more than enough.
const RECEIVER_BUFFER_SIZE: usize = 4;

/// Waits for the first first receiver on the vector to receive a value, or stalls indefinitely if
/// the vector is empty. Upon completion, the receiver in question is removed from the vector.
async fn get_first<T>(receivers: &mut Vec<oneshot::Receiver<T>>) -> Result<T, oneshot::error::RecvError> {
    poll_fn(|cx| {
        if let Some(rx) = receivers.first_mut() {
            if let Poll::Ready(result) = Pin::new(rx).poll(cx) {
                receivers.remove(0);
                return Poll::Ready(result);
            }
        }

        Poll::Pending
    })
    .await
}

/// Completes immediately if the writer's buffer isn't empty, otherwise stalls indefinitely.
///
/// This is useful because `BufWriter` doesn't flush unless it gets full or is told to flush. That
/// means that if we write a response to a message we'd need to flush it immediately, as otherwise
/// that response might wait indefinitely to be sent!
///
/// However, flushing after each response might be very inefficient, specially given that most
/// responses are pretty small, some even a single byte. Also, what if we receive, in a single
/// read, three requests from a client and want to send back the three responses in a single write?
///
/// This helper function makes handling that easy. Instead of flushing the buffer after each write,
/// place the future generated by this function as the last branch in a biased `select!` block like
/// so:
///
/// ```
/// loop {
///     select! {
///         biased;
///         ... // handle messages & responses, write things to the writer
///         _ = stall_if_empty(writer) => writer.flush().await,
///     }
/// }
/// ````
///
/// And now the writer will be automatically flushed when it's not empty, and there's nothing else
/// that needs writing to it.
async fn stall_if_empty<W>(writer: &BufWriter<W>)
where
    W: AsyncWrite + Unpin,
{
    poll_fn(|_| {
        if writer.buffer().is_empty() {
            Poll::Pending
        } else {
            Poll::Ready(())
        }
    })
    .await;
}

pub async fn handle_responses<W>(
    writer: &mut BufWriter<W>,
    _context: &SandstormContext,
    mut response_notifier: mpsc::Receiver<ResponseNotification>,
) -> Result<(), io::Error>
where
    W: AsyncWrite + Unpin,
{
    let mut list_socks_receivers: Vec<oneshot::Receiver<Vec<SocketAddr>>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);
    let mut add_socks_receivers: Vec<oneshot::Receiver<Result<(), io::Error>>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);
    let mut remove_socks_receivers: Vec<oneshot::Receiver<bool>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);
    let mut list_sandstorm_receivers: Vec<oneshot::Receiver<Vec<SocketAddr>>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);
    let mut add_sandstorm_receivers: Vec<oneshot::Receiver<Result<(), io::Error>>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);
    let mut remove_sandstorm_receivers: Vec<oneshot::Receiver<bool>> = Vec::with_capacity(RECEIVER_BUFFER_SIZE);

    loop {
        select! {
            biased;
            maybe_notification = response_notifier.recv() => {
                let notification = match maybe_notification {
                    Some(notif) => notif,
                    None => return Ok(()),
                };

                handle_notification(
                    notification,
                    writer,
                    &mut list_socks_receivers,
                    &mut add_socks_receivers,
                    &mut remove_socks_receivers,
                    &mut list_sandstorm_receivers,
                    &mut add_sandstorm_receivers,
                    &mut remove_sandstorm_receivers
                ).await?;
            }
            sockets = get_first(&mut list_socks_receivers) => {
                let sockets = sockets.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSocks5Sockets, sockets).write(writer).await?;
            }
            result = get_first(&mut add_socks_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::AddSocks5Socket, result).write(writer).await?;
            }
            result = get_first(&mut remove_socks_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::RemoveSocks5Socket, result).write(writer).await?;
            }
            sockets = get_first(&mut list_sandstorm_receivers) => {
                let sockets = sockets.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSandstormSockets, sockets).write(writer).await?;
            }
            result = get_first(&mut add_sandstorm_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::AddSandstormSocket, result).write(writer).await?;
            }
            result = get_first(&mut remove_sandstorm_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::RemoveSandstormSocket, result).write(writer).await?;
            }
            _ = stall_if_empty(writer) => writer.flush().await?,
        }
    }
}

#[allow(clippy::too_many_arguments)]
async fn handle_notification<W>(
    notification: ResponseNotification,
    writer: &mut W,
    list_socks_receivers: &mut Vec<oneshot::Receiver<Vec<SocketAddr>>>,
    add_socks_receivers: &mut Vec<oneshot::Receiver<Result<(), io::Error>>>,
    remove_socks_receivers: &mut Vec<oneshot::Receiver<bool>>,
    list_sandstorm_receivers: &mut Vec<oneshot::Receiver<Vec<SocketAddr>>>,
    add_sandstorm_receivers: &mut Vec<oneshot::Receiver<Result<(), io::Error>>>,
    remove_sandstorm_receivers: &mut Vec<oneshot::Receiver<bool>>,
) -> Result<(), io::Error>
where
    W: AsyncWrite + Unpin + ?Sized,
{
    match notification {
        ResponseNotification::Shutdown(receiver) => {
            let _ = receiver.await;
            SandstormCommandType::Shutdown.write(writer).await?;
        }
        // LogEventConfig(),
        // LogEventStream(),
        ResponseNotification::ListSocks5Sockets(receiver) => {
            if list_socks_receivers.len() == list_socks_receivers.capacity() {
                let sockets = list_socks_receivers.remove(0).await.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSocks5Sockets, sockets).write(writer).await?;
            }
            list_socks_receivers.push(receiver);
        }
        ResponseNotification::AddSocks5Socket(receiver) => {
            if add_socks_receivers.len() == add_socks_receivers.capacity() {
                let result = add_socks_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::AddSocks5Socket, result).write(writer).await?;
            }
            add_socks_receivers.push(receiver);
        }
        ResponseNotification::RemoveSocks5Socket(receiver) => {
            if remove_socks_receivers.len() == remove_socks_receivers.capacity() {
                let result = remove_socks_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::RemoveSocks5Socket, !result).write(writer).await?;
            }
            remove_socks_receivers.push(receiver);
        }
        ResponseNotification::ListSandstormSockets(receiver) => {
            if list_sandstorm_receivers.len() == list_sandstorm_receivers.capacity() {
                let sockets = list_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSandstormSockets, sockets).write(writer).await?;
            }
            list_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::AddSandstormSocket(receiver) => {
            if add_sandstorm_receivers.len() == add_sandstorm_receivers.capacity() {
                let result = add_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::AddSandstormSocket, result).write(writer).await?;
            }
            add_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::RemoveSandstormSocket(receiver) => {
            if remove_sandstorm_receivers.len() == remove_sandstorm_receivers.capacity() {
                let result = remove_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::RemoveSandstormSocket, !result).write(writer).await?;
            }
            remove_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::ListUsers(snapshot) => {
            (SandstormCommandType::ListUsers, snapshot.as_slice()).write(writer).await?;
        }
        ResponseNotification::AddUser(result) => {
            (SandstormCommandType::AddUser, result).write(writer).await?;
        }
        ResponseNotification::UpdateUser(result) => {
            (SandstormCommandType::UpdateUser, result).write(writer).await?;
        }
        ResponseNotification::DeleteUser(result) => {
            (SandstormCommandType::DeleteUser, result).write(writer).await?;
        }
        ResponseNotification::ListAuthMethods(auth_methods) => {
            let auth_methods = SmallWriteList(auth_methods.as_slice());
            (SandstormCommandType::ListAuthMethods, auth_methods).write(writer).await?;
        }
        ResponseNotification::ToggleAuthMethod(result) => {
            (SandstormCommandType::ToggleAuthMethod, result).write(writer).await?;
        }
        // RequestCurrentMetrics(),
        ResponseNotification::GetBufferSize(buffer_size) => {
            (SandstormCommandType::GetBufferSize, buffer_size).write(writer).await?;
        }
        ResponseNotification::SetBufferSize(result) => {
            (SandstormCommandType::SetBufferSize, result).write(writer).await?;
        }
        ResponseNotification::Meow => {
            SandstormCommandType::Meow.write(writer).await?;
            writer.write_all(b"MEOW").await?;
        }
    }

    Ok(())
}
