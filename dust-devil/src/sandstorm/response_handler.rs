use std::{
    future::{poll_fn, Future},
    io::{self, ErrorKind},
    net::SocketAddr,
    pin::Pin,
    sync::Arc,
    task::Poll,
};

use dust_devil_core::{
    logging::LogEvent,
    sandstorm::{Metrics, SandstormCommandType},
    serialize::{ByteWrite, SmallWriteList},
};
use tokio::{
    io::{AsyncWrite, AsyncWriteExt, BufWriter},
    select,
    sync::{broadcast, mpsc, oneshot},
};

use crate::context::SandstormContext;

use super::{error_handling::ToIoResult, messaging::ResponseNotification};

/// The maximum amount requests for a specific message type (e.g. "list socks5 sockets") that can
/// pile up before the response handler starts waiting on them to be completed synchronously.
///
/// This doesn't need to be a high value; why would anyone be asking to list/add/remove a socks5 or
/// sandstorm sockets over and over again repeatedly without delay? 4 is more than enough.
const RECEIVER_BUFFER_SIZE: usize = 4;

/// Waits for the first first receiver on the vector to receive a value, or stalls indefinitely if
/// the vector is empty. Upon completion, the receiver in question is removed from the vector.
async fn get_first<T>(receivers: &mut Vec<oneshot::Receiver<T>>) -> Result<T, oneshot::error::RecvError> {
    poll_fn(|cx| {
        if let Some(rx) = receivers.first_mut() {
            if let Poll::Ready(result) = Pin::new(rx).poll(cx) {
                receivers.remove(0);
                return Poll::Ready(result);
            }
        }

        Poll::Pending
    })
    .await
}

/// Same as get_first(), but instead of a plain receiver, it's an optional receiver. If a value is
/// None, it gets returned immediately.
async fn get_first_optional<T>(receivers: &mut Vec<Option<oneshot::Receiver<T>>>) -> Result<Option<T>, oneshot::error::RecvError> {
    poll_fn(|cx| {
        if let Some(rx) = receivers.first_mut() {
            let rx = match rx {
                Some(r) => r,
                None => return Poll::Ready(Ok(None)),
            };

            if let Poll::Ready(result) = Pin::new(rx).poll(cx) {
                receivers.remove(0);
                return Poll::Ready(result.map(|v| Some(v)));
            }
        }

        Poll::Pending
    })
    .await
}

async fn recv_if_some<T: Clone>(maybe_receiver: &mut Option<broadcast::Receiver<T>>) -> Result<T, broadcast::error::RecvError> {
    if let Some(receiver) = maybe_receiver {
        receiver.recv().await
    } else {
        poll_fn(|_| Poll::Pending).await
    }
}

/// Completes immediately if the writer's buffer isn't empty, otherwise stalls indefinitely.
///
/// This is useful because `BufWriter` doesn't flush unless it gets full or is told to flush. That
/// means that if we write a response to a message we'd need to flush it immediately, as otherwise
/// that response might wait indefinitely to be sent!
///
/// However, flushing after each response might be very inefficient, specially given that most
/// responses are pretty small, some even a single byte. Also, what if we receive, in a single
/// read, three requests from a client and want to send back the three responses in a single write?
///
/// This helper function makes handling that easy. Instead of flushing the buffer after each write,
/// place the future generated by this function as the last branch in a biased `select!` block like
/// so:
///
/// ```
/// loop {
///     select! {
///         biased;
///         ... // handle messages & responses, write things to the writer
///         _ = stall_if_empty(writer) => writer.flush().await,
///     }
/// }
/// ````
///
/// And now the writer will be automatically flushed when it's not empty, and there's nothing else
/// that needs writing to it.
async fn stall_if_empty<W>(writer: &BufWriter<W>)
where
    W: AsyncWrite + Unpin,
{
    poll_fn(|_| {
        if writer.buffer().is_empty() {
            Poll::Pending
        } else {
            Poll::Ready(())
        }
    })
    .await;
}

struct ResponseHandlerState {
    list_socks_receivers: Vec<oneshot::Receiver<Vec<SocketAddr>>>,
    add_socks_receivers: Vec<oneshot::Receiver<Result<(), io::Error>>>,
    remove_socks_receivers: Vec<oneshot::Receiver<bool>>,
    list_sandstorm_receivers: Vec<oneshot::Receiver<Vec<SocketAddr>>>,
    add_sandstorm_receivers: Vec<oneshot::Receiver<Result<(), io::Error>>>,
    remove_sandstorm_receivers: Vec<oneshot::Receiver<bool>>,
    metrics_receivers: Vec<Option<oneshot::Receiver<Metrics>>>,
    event_stream_receiver: Option<broadcast::Receiver<Arc<LogEvent>>>,
}

pub async fn handle_responses<W>(
    writer: &mut BufWriter<W>,
    context: &SandstormContext,
    mut response_notifier: mpsc::Receiver<ResponseNotification>,
) -> Result<(), io::Error>
where
    W: AsyncWrite + Unpin,
{
    let mut handler_state = ResponseHandlerState {
        list_socks_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        add_socks_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        remove_socks_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        list_sandstorm_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        add_sandstorm_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        remove_sandstorm_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        metrics_receivers: Vec::with_capacity(RECEIVER_BUFFER_SIZE),
        event_stream_receiver: None,
    };

    loop {
        select! {
            biased;
            maybe_notification = response_notifier.recv() => {
                let notification = match maybe_notification {
                    Some(notif) => notif,
                    None => return Ok(()),
                };

                handle_notification(
                    notification,
                    writer,
                    context,
                    &mut handler_state
                ).await?;
            }
            sockets = get_first(&mut handler_state.list_socks_receivers) => {
                let sockets = sockets.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSocks5Sockets, sockets).write(writer).await?;
            }
            result = get_first(&mut handler_state.add_socks_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::AddSocks5Socket, result).write(writer).await?;
            }
            result = get_first(&mut handler_state.remove_socks_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::RemoveSocks5Socket, result).write(writer).await?;
            }
            sockets = get_first(&mut handler_state.list_sandstorm_receivers) => {
                let sockets = sockets.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSandstormSockets, sockets).write(writer).await?;
            }
            result = get_first(&mut handler_state.add_sandstorm_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::AddSandstormSocket, result).write(writer).await?;
            }
            result = get_first(&mut handler_state.remove_sandstorm_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::RemoveSandstormSocket, result).write(writer).await?;
            }
            result = get_first_optional(&mut handler_state.metrics_receivers) => {
                let result = result.map_err_to_io()?;
                (SandstormCommandType::RequestCurrentMetrics, result).write(writer).await?;
            }
            maybe_event = recv_if_some(&mut handler_state.event_stream_receiver) => {
                match maybe_event {
                    Ok(evt) => (SandstormCommandType::LogEventStream, evt.as_ref()).write(writer).await?,
                    Err(broadcast::error::RecvError::Closed) => return Ok(()),
                    Err(broadcast::error::RecvError::Lagged(count)) => return Err(io::Error::new(ErrorKind::Other, format!("Connection too slow to stream events, lagged behind {count} events!"))),
                }
            }
            _ = stall_if_empty(writer) => writer.flush().await?,
        }
    }
}

async fn handle_notification<W>(
    notification: ResponseNotification,
    writer: &mut W,
    context: &SandstormContext,
    handler_state: &mut ResponseHandlerState,
) -> Result<(), io::Error>
where
    W: AsyncWrite + Unpin + ?Sized,
{
    match notification {
        ResponseNotification::Shutdown(receiver) => {
            let _ = receiver.await;
            SandstormCommandType::Shutdown.write(writer).await?;
        }
        ResponseNotification::LogEventConfig(enabled) => {
            let (result, maybe_metrics) = match (enabled, &handler_state.event_stream_receiver) {
                (false, _) => {
                    handler_state.event_stream_receiver.take();
                    (0u8, None)
                }
                (true, Some(_)) => (2, None),
                (true, None) => match context.request_metrics_and_subscribe().await {
                    Some(result_receiver) => {
                        let (metrics, event_receiver) = result_receiver.await.map_err_to_io()?;
                        handler_state.event_stream_receiver = Some(event_receiver);
                        (1u8, Some(metrics))
                    }
                    None => (0u8, None),
                },
            };

            (SandstormCommandType::LogEventConfig, result).write(writer).await?;
            if let Some(metrics) = maybe_metrics {
                metrics.write(writer).await?;
            }
        }
        ResponseNotification::ListSocks5Sockets(receiver) => {
            if handler_state.list_socks_receivers.len() == handler_state.list_socks_receivers.capacity() {
                let sockets = handler_state.list_socks_receivers.remove(0).await.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSocks5Sockets, sockets).write(writer).await?;
            }
            handler_state.list_socks_receivers.push(receiver);
        }
        ResponseNotification::AddSocks5Socket(receiver) => {
            if handler_state.add_socks_receivers.len() == handler_state.add_socks_receivers.capacity() {
                let result = handler_state.add_socks_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::AddSocks5Socket, result).write(writer).await?;
            }
            handler_state.add_socks_receivers.push(receiver);
        }
        ResponseNotification::RemoveSocks5Socket(receiver) => {
            if handler_state.remove_socks_receivers.len() == handler_state.remove_socks_receivers.capacity() {
                let result = handler_state.remove_socks_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::RemoveSocks5Socket, !result).write(writer).await?;
            }
            handler_state.remove_socks_receivers.push(receiver);
        }
        ResponseNotification::ListSandstormSockets(receiver) => {
            if handler_state.list_sandstorm_receivers.len() == handler_state.list_sandstorm_receivers.capacity() {
                let sockets = handler_state.list_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                let sockets = sockets.as_slice();
                (SandstormCommandType::ListSandstormSockets, sockets).write(writer).await?;
            }
            handler_state.list_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::AddSandstormSocket(receiver) => {
            if handler_state.add_sandstorm_receivers.len() == handler_state.add_sandstorm_receivers.capacity() {
                let result = handler_state.add_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::AddSandstormSocket, result).write(writer).await?;
            }
            handler_state.add_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::RemoveSandstormSocket(receiver) => {
            if handler_state.remove_sandstorm_receivers.len() == handler_state.remove_sandstorm_receivers.capacity() {
                let result = handler_state.remove_sandstorm_receivers.remove(0).await.map_err_to_io()?;
                (SandstormCommandType::RemoveSandstormSocket, !result).write(writer).await?;
            }
            handler_state.remove_sandstorm_receivers.push(receiver);
        }
        ResponseNotification::ListUsers(snapshot) => {
            (SandstormCommandType::ListUsers, snapshot.as_slice()).write(writer).await?;
        }
        ResponseNotification::AddUser(result) => {
            (SandstormCommandType::AddUser, result).write(writer).await?;
        }
        ResponseNotification::UpdateUser(result) => {
            (SandstormCommandType::UpdateUser, result).write(writer).await?;
        }
        ResponseNotification::DeleteUser(result) => {
            (SandstormCommandType::DeleteUser, result).write(writer).await?;
        }
        ResponseNotification::ListAuthMethods(auth_methods) => {
            let auth_methods = SmallWriteList(auth_methods.as_slice());
            (SandstormCommandType::ListAuthMethods, auth_methods).write(writer).await?;
        }
        ResponseNotification::ToggleAuthMethod(result) => {
            (SandstormCommandType::ToggleAuthMethod, result).write(writer).await?;
        }
        ResponseNotification::RequestCurrentMetrics(maybe_receiver) => {
            if handler_state.metrics_receivers.len() == handler_state.metrics_receivers.capacity() {
                let maybe_receiver = handler_state.metrics_receivers.remove(0);
                let result = match maybe_receiver {
                    Some(receiver) => Some(receiver.await.map_err_to_io()?),
                    None => None,
                };
                (SandstormCommandType::RequestCurrentMetrics, result).write(writer).await?;
            }

            handler_state.metrics_receivers.push(maybe_receiver);
        }
        ResponseNotification::GetBufferSize(buffer_size) => {
            (SandstormCommandType::GetBufferSize, buffer_size).write(writer).await?;
        }
        ResponseNotification::SetBufferSize(result) => {
            (SandstormCommandType::SetBufferSize, result).write(writer).await?;
        }
        ResponseNotification::Meow => {
            SandstormCommandType::Meow.write(writer).await?;
            writer.write_all(b"MEOW").await?;
        }
    }

    Ok(())
}
